<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>FIRM Client Test</title>
    <style>
      :root {
        --theme-color: #f85e39;
        --bg-color: #ffffff;
        --text-color: #1a1a1a;
      }

      body {
        font-family:
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          sans-serif;
        background: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        gap: 1.5rem;
        margin: 3rem auto;
        max-width: 600px;
      }

      h1 {
        color: var(--theme-color);
        margin-bottom: 0.5rem;
        font-size: 1.8rem;
      }

      button {
        background: var(--theme-color);
        color: white;
        border: none;
        border-radius: 8px;
        padding: 0.7rem 1.5rem;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      button:hover {
        background: #d94f2f;
      }

      #output {
        width: 100%;
        height: 150px;
        background: #f9f9f9;
        border: 2px solid var(--theme-color);
        border-radius: 10px;
        padding: 1rem;
        font-family: monospace;
        font-size: 0.8rem;
        white-space: pre-wrap;
        overflow-y: auto;
        color: #333;
        text-align: left;
      }

      #rawBytes {
        width: 100%;
        height: 140px;
        background: #f9f9f9;
        border: 2px solid var(--theme-color);
        border-radius: 10px;
        padding: 1rem;
        font-family: monospace;
        font-size: 0.8rem;
        white-space: pre;
        overflow-y: auto;
        color: #333;
        resize: vertical;
      }

      .controls {
        display: none;
        flex-direction: column;
        gap: 1rem;
        width: 100%;
        padding: 1rem;
        background: #f0f0f0;
        border-radius: 8px;
      }

      .control-row {
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      input[type='text'] {
        padding: 0.7rem;
        border-radius: 5px;
        border: 1px solid #ccc;
        flex-grow: 1;
      }

      .status {
        font-size: 0.9rem;
        color: #666;
      }
    </style>
  </head>
  <body>
    <h1>FIRM Client Test</h1>
    <button id="connect">Connect to Device</button>
    <div class="status" id="status">Waiting for connection...</div>

    <div id="controls" class="controls">
      <div class="control-row">
        <input type="text" id="deviceNameInput" placeholder="New Device Name" />
        <button id="setConfigBtn">Set Name</button>
      </div>
      <div class="control-row">
        <button id="getConfigBtn">Get Device Config</button>
        <button id="getInfoBtn">Get Device Info</button>
      </div>
      <div class="control-row">
        <button id="runMagCalBtn">Run Mag Calibration</button>
        <button id="cancelBtn">Cancel</button>
        <button id="rebootBtn">Reboot</button>
      </div>
      <div
        id="configOutput"
        style="
          background: #fff;
          padding: 0.5rem;
          border: 1px solid #ddd;
          border-radius: 4px;
          min-height: 20px;
          font-family: monospace;
        "
      >
        Config output...
      </div>
    </div>

    <h3>Latest Packet:</h3>
    <div id="output">{ No packet data yet }</div>

    <h3>Incoming Serial Bytes:</h3>
    <textarea id="rawBytes" readonly>{ No raw bytes yet }</textarea>

    <script type="module">
      // Use the same public API as npm consumers
      import { FIRM } from '/firm_typescript/typescript/dist/index.js';

      const btn = document.getElementById('connect');
      const output = document.getElementById('output');
      const status = document.getElementById('status');
      const controls = document.getElementById('controls');
      const deviceNameInput = document.getElementById('deviceNameInput');
      const setConfigBtn = document.getElementById('setConfigBtn');
      const getConfigBtn = document.getElementById('getConfigBtn');
      const getInfoBtn = document.getElementById('getInfoBtn');
      const runMagCalBtn = document.getElementById('runMagCalBtn');
      const cancelBtn = document.getElementById('cancelBtn');
      const rebootBtn = document.getElementById('rebootBtn');
      const configOutput = document.getElementById('configOutput');
      const rawBytesEl = document.getElementById('rawBytes');

      let firmInstance = null;
      let unsubscribeRawBytes = null;

      function setStatus(msg) {
        status.textContent = msg;
      }

      function showPacket(pkt) {
        // pkt is now a plain JS object thanks to serde-wasm-bindgen
        output.textContent = JSON.stringify(pkt, null, 2);
      }

      function bytesToHex(bytes) {
        // Space-separated 2-digit hex
        return Array.from(bytes)
          .map((b) => b.toString(16).padStart(2, '0'))
          .join(' ');
      }

      setConfigBtn.addEventListener('click', async () => {
        if (!firmInstance) return;
        const name = deviceNameInput.value;
        if (!name) {
          alert('Please enter a name');
          return;
        }
        setStatus('[UI] Setting device name...');
        // Defaulting frequency to 100 and protocol to 1 (USB) for this test
        const success = await firmInstance.setDeviceConfig(name, 100, 1);
        if (success) {
          setStatus('[UI] Device name set successfully!');
          configOutput.textContent = `Success: Name set to "${name}"`;
        } else {
          setStatus('[UI] Failed to set device name (timeout).');
          configOutput.textContent = 'Error: Timeout waiting for response.';
        }
      });

      getConfigBtn.addEventListener('click', async () => {
        if (!firmInstance) return;
        setStatus('[UI] Getting device config...');
        const config = await firmInstance.getDeviceConfig();
        if (config) {
          setStatus('[UI] Config received.');
          configOutput.textContent = JSON.stringify(config, null, 2);
        } else {
          setStatus('[UI] Failed to get config (timeout).');
          configOutput.textContent = 'Error: Timeout waiting for response.';
        }
      });

      getInfoBtn.addEventListener('click', async () => {
        if (!firmInstance) return;
        setStatus('[UI] Getting device info...');
        const info = await firmInstance.getDeviceInfo();
        if (info) {
          setStatus('[UI] Info received.');
          configOutput.textContent = JSON.stringify(info, null, 2);
        } else {
          setStatus('[UI] Failed to get info (timeout).');
          configOutput.textContent = 'Error: Timeout waiting for response.';
        }
      });

      runMagCalBtn.addEventListener('click', async () => {
        if (!firmInstance) return;
        setStatus('[UI] Running magnetometer calibration...');
        const res = await firmInstance.runMagnetometerCalibration();
        if (res) {
          setStatus('[UI] Magnetometer calibration response received.');
          configOutput.textContent = JSON.stringify(res, null, 2);
        } else {
          setStatus('[UI] Magnetometer calibration timed out.');
          configOutput.textContent = 'Error: Timeout waiting for response.';
        }
      });

      cancelBtn.addEventListener('click', async () => {
        if (!firmInstance) return;
        setStatus('[UI] Sending cancel command...');
        const ack = await firmInstance.sendCancelCommand();
        if (ack === null) {
          setStatus('[UI] Cancel timed out.');
          configOutput.textContent = 'Error: Timeout waiting for response.';
        } else if (ack) {
          setStatus('[UI] Cancel acknowledged.');
          configOutput.textContent = 'Cancel acknowledged.';
        } else {
          setStatus('[UI] Cancel not acknowledged.');
          configOutput.textContent = 'Cancel not acknowledged.';
        }
      });

      rebootBtn.addEventListener('click', async () => {
        if (!firmInstance) return;
        setStatus('[UI] Sending reboot command...');
        try {
          await firmInstance.reboot();
          setStatus('[UI] Reboot command sent.');
          configOutput.textContent = 'Reboot command sent.';

          // Reboot will drop the serial connection; proactively reset UI.
          await cleanupDisconnectedUI();
          setStatus('[UI] Disconnected (reboot).');
        } catch (err) {
          console.error(err);
          setStatus('[UI] Failed to send reboot command.');
          configOutput.textContent = 'Error: Failed to send reboot command.';
        }
      });

      async function cleanupDisconnectedUI() {
        // Idempotent; never throws.
        btn.disabled = true;

        const instanceToClose = firmInstance;
        firmInstance = null;

        try {
          unsubscribeRawBytes?.();
        } catch {
          // ignore
        }
        unsubscribeRawBytes = null;

        try {
          await instanceToClose?.close?.();
        } catch (e) {
          console.warn('[UI] close() failed (ignored):', e);
        }

        controls.style.display = 'none';
        btn.textContent = 'Connect to Device';
        btn.disabled = false;
      }

      btn.addEventListener('click', async () => {
        btn.disabled = true;
        setStatus('[UI] Connecting...');

        try {
          const firm = await FIRM.connect({ baudRate: 115200 });
          firmInstance = firm;
          setStatus('[UI] Connected. Streaming packets...');
          controls.style.display = 'flex';
          btn.textContent = 'Connect to Device';
          btn.disabled = true;

          // Show raw incoming serial bytes.
          let rawLog = '';
          const MAX_CHARS = 20000;
          unsubscribeRawBytes = firm.onRawBytes((bytes) => {
            rawLog += bytesToHex(bytes) + '\n';
            if (rawLog.length > MAX_CHARS) {
              rawLog = rawLog.slice(rawLog.length - MAX_CHARS);
            }
            rawBytesEl.value = rawLog;
            rawBytesEl.scrollTop = rawBytesEl.scrollHeight;
          });

          // Stream packets in the background; if it ends/errors, restore UI so reconnect works.
          (async () => {
            try {
              for await (const pkt of firm.getDataPackets()) {
                showPacket(pkt);
              }
              setStatus('[UI] Stream ended.');
            } catch (err) {
              console.error(err);
              setStatus('Error: ' + (err?.message ?? err));
            } finally {
              await cleanupDisconnectedUI();
            }
          })().catch((e) => {
            console.error('[UI] stream task error:', e);
          });
        } catch (err) {
          console.error(err);
          setStatus('Error: ' + (err?.message ?? err));
          btn.textContent = 'Connect to Device';
          btn.disabled = false;
        }
      });
    </script>
  </body>
</html>
